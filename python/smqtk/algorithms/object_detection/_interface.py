import abc
import hashlib

import six

from smqtk.algorithms import SmqtkAlgorithm
from smqtk.utils import ContentTypeValidator

from ._defaults import DFLT_CLASSIFIER_FACTORY, DFLT_DETECTION_FACTORY


@six.add_metaclass(abc.ABCMeta)
class ObjectDetector (SmqtkAlgorithm, ContentTypeValidator):
    """
    Abstract interface to an object detection algorithm.

    An object detection algorithm is one that can take in data and output zero
    or more detection elements, where each detection represents a spatial
    region in the data.

    This high level interface only requires detection element returns (spatial
    bounding-boxes with associated classification elements).
    """

    __slots__ = ()

    @staticmethod
    def _gen_detection_uuid(data_uuid, bbox, labels):
        """
        Local standard for producing the UUID of a DetectionElement based on
        parent data, component bounding box and classification labels.

        :param str data_uuid:
            UUID of parent data element (checksum hash string) this detection
            is derived from.
        :param smqtk.representation.AxisAlignedBoundingBox bbox:
            Detection bounding box instance.
        :param labels:
            Sequence of string classification labels.

        :return: Detection UUID string that is the SHA1 checksum of the
            component data.

        """
        # noinspection PyStringFormat
        # - uses variadic expansion which fools current linter.
        hashable = data_uuid + \
            '{}{}{}{}'.format(*(bbox.min_vertex.tolist() +
                                bbox.max_vertex.tolist())) + \
            ''.join(sorted(labels))
        return hashlib.sha1(hashable).hexdigest()

    def detect_objects(self, data_element,
                       de_factory=DFLT_DETECTION_FACTORY,
                       ce_factory=DFLT_CLASSIFIER_FACTORY):
        """
        Detect objects in the given data.

        UUIDs of detections are based on the hash produced from the combination
        of:
            - Detection bounding-box bounding coordinates
            - Classification label set predicted for a bounding box.

        :param smqtk.representation.DataElement data_element:
            Source data from which to detect objects within.
        :param smqtk.representation.DetectionElementFactory de_factory:
            Factory for generating DetectionElement instances. The default
            factory yields MemoryClassificationElement instances.
        :param smqtk.representation.ClassificationElementFactory ce_factory:
            Factory for generating ClassificationElement instances for
            detections. The default factory yields MemoryClassificationElement
            instances.

        :raises ValueError: Given data element content was not of a valid
            content type that this class reports as valid for object detection.

        :return: Iterator over result DetectionElement instances as generated
            by the given DetectionElementFactory, containing classification
            elements as generated by the given ClassificationElementFactory.
        :rtype: collections.Iterable[smqtk.representation.DetectionElement]

        """
        self.raise_valid_element(data_element)

        # We know that the UUID of a DataElement should be a checksum of sorts,
        # so we can generally assume a string-cast is unique preserving.
        de_uuid = str(data_element.uuid())

        for bbox, c_map in self._detect_objects(data_element):
            # Determine UUID of detection from bbox and classification labels
            det_uuid = self._gen_detection_uuid(de_uuid, bbox, c_map.keys())

            ce = ce_factory.new_classification('object detection '
                                               'classification', det_uuid)
            ce.set_classification(c_map)

            de = de_factory.new_detection(det_uuid).set_detection(bbox, ce)
            yield de

    @abc.abstractmethod
    def _detect_objects(self, data):
        """
        Internal method that defines the generation of paired bounding boxes
        and classification maps for detected objects in the given data.

        :param smqtk.representation.DataElement data:
            Source data (DataElement) from which to detect objects within.

        :return: Iterable over paired ``AxisAlignedBoundingBox`` and
            classification map for detected objects. The returned
            "classification map" should follow the format described by
            ``smqtk.representation.ClassificationElement``: dictionary where
            keys are classification labels and values are classification
            probabilities.
        :rtype:
            collections.Iterator[(smqtk.representation.AxisAlignedBoundingBox,
                                  dict[collections.Hashable, float])]

        """
